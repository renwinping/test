#include "http_client_connect.h"



void http_client_connect::http_request_done(struct evhttp_request *req, void *arg)
{
    if (!arg) {
        WARNING_LOG("arg is NULL");
        return ;    
    }

    event_dispatch_msg * msg = (event_dispatch_msg *)arg;
    REC_OBJ<event_dispatch_msg> rc(msg);

    res_from_http rs_http;

    if (req) {
        struct evbuffer* buf = evhttp_request_get_input_buffer(req);
        size_t len = evbuffer_get_length(buf);
        unsigned char * str = evbuffer_pullup(req->input_buffer, len);

        rs_http.res_code = req->response_code;
        if (str)
            rs_http.res_buf.append((const char*)str, len);
        else 
            rs_http.res_buf.append("len: %d str is NULL", len);

        evbuffer_drain(buf, len);

    } else {

        rs_http.res_code = 2;
        rs_http.res_buf.append("req is NULL");
    }

    DEBUG_LOG("sid: %s res_code[%d] res_buf[%s]", msg->sid.c_str(), rs_http.res_code, rs_http.res_buf.c_str());

    if (msg && msg->ad_event) {
        msg->ad_event->process_form_http(msg, rs_http);
    }
}



void http_client_connect::do_request(uint64_t now, event_dispatch_msg * msg, struct event_base* base)
{
    res_from_http rs_http;
    int ret = 0;
    map<string, string>::iterator it;
    char t_buf[SIZE_LEN_2048];

    DEBUG_LOG("sid:%s", msg->sid.c_str());
    uint64_t diff_time = now - msg->_start_time; 
    if (diff_time >= base_singleton<dsp_conf>::get_instance()->ub_event_timeout) {
        rs_http.res_code = 2;
        rs_http.res_buf.append("msg has time_out");
        goto ERR;
    }

    msg->uri = evhttp_uri_parse(base_singleton<dsp_conf>::get_instance()->req_url);
    if (!msg->uri) {
        rs_http.res_code = 4;
        rs_http.res_buf.append("evhttp_uri_parse failed");
        goto ERR;
    }
    
    int port = evhttp_uri_get_port(msg->uri); 

    if (port == -1){
        port = 80;
    }

    msg->cn = evhttp_connection_base_new(base,NULL, evhttp_uri_get_host(msg->uri), port);
    if (!msg->cn) {
        rs_http.res_code = 4;
        rs_http.res_buf.append("evhttp_connection_base_new failed");
        goto ERR;
    }

    struct evhttp_request * req = evhttp_request_new(http_request_done, msg);
    if (!req) {
        rs_http.res_code = 4;
        rs_http.res_buf.append("evhttp_request_new failed");
        goto ERR;
    }

    evhttp_add_header(req->output_headers, "Host", evhttp_uri_get_host(msg->uri));

    evhttp_add_header(req->output_headers, "Connection", "close");


    for (it = msg->headers.begin(); it != msg->headers.end(); it++) {
        evhttp_add_header(req->output_headers, it->first.c_str(), it->second.c_str());
    }

    const char *path = evhttp_uri_get_path(msg->uri);
    const char *query = evhttp_uri_get_query(msg->uri); 

    if (query != NULL) {
        snprintf(t_buf, sizeof(t_buf), "%s?%s", path, query);
    }else {
        snprintf(t_buf, sizeof(t_buf), "%s", path);
    }


    if (msg->http_mode == AD_HTTP_GET) {
            
        ret = evhttp_make_request(msg->cn, req, EVHTTP_REQ_GET, t_buf); 

    } else if (msg->http_mode == AD_HTTP_POST) {
        
        evbuffer_add(req->output_buffer, msg->post_data.c_str(), msg->post_data.length());

        ret = evhttp_make_request(msg->cn, req, EVHTTP_REQ_POST, t_buf); 
    }

    if (ret) {

        rs_http.res_code = 4;
        rs_http.res_buf.append("evhttp_make_request failed");

        goto ERR;
    }

    //evhttp_connection_set_timeout(req->evcon, msg->time_out);
    struct timeval tv;
    tv.tv_usec = base_singleton<dsp_conf>::get_instance()->http_connect_timeout;
    tv.tv_sec = 0;
    evhttp_connection_set_timeout_tv(req->evcon, &tv);
    return ;

ERR:

    if (msg->ad_event) {
        msg->ad_event->process_form_http(msg, rs_http);
    }

    REC_OBJ<event_dispatch_msg> rc(msg);

    WARNING_LOG("sid: %s res_code[%d] res_buf[%s]", msg->sid.c_str(), rs_http.res_code, rs_http.res_buf.c_str());

    return ;
}


void http_client_connect::init(const string & url, job_connect * t_conn)
{
    _url = url;
    _t_conn = t_conn;

    _uri = evhttp_uri_parse(url.c_str());
    
    int port = evhttp_uri_get_port(_uri); 

    if (port == -1){
        port = 80;
    }

    //LOG_DEBUG("url:%s", _url.c_str());
    _cn = evhttp_connection_base_new(_thread->get_event_base(),NULL, evhttp_uri_get_host(_uri), port);

    _req = evhttp_request_new(http_request_done, this);

    evhttp_add_header(_req->output_headers, "Host", evhttp_uri_get_host(_uri));

    const char *query = evhttp_uri_get_query(_uri); 
    const char *path = evhttp_uri_get_path(_uri);

    char t_buf[SIZE_LEN_2048];

    snprintf(t_buf, sizeof(t_buf), "%s?%s", path, query);
    evhttp_make_request(_cn, _req, EVHTTP_REQ_GET, t_buf); 
    evhttp_connection_set_timeout(_req->evcon, 600);

    //LOG_DEBUG("host:%s, path:%s, query:%s, port:%d", evhttp_uri_get_host(_uri), path, query, port);
    //LOG_DEBUG("t_buf:%s", t_buf);
}

void http_client_connect::call_back(struct evhttp_request *req, void *arg)
{
   switch(req->response_code)
   {
        case HTTP_OK:
            {
                struct evbuffer* buf = evhttp_request_get_input_buffer(req);
                size_t len = evbuffer_get_length(buf);
                unsigned char * str = evbuffer_pullup(req->input_buffer, len);
                //LOG_DEBUG("http_request_done: %s", str);
                int r_len = snprintf(_res_buf, sizeof(_res_buf), "%s", str);
                //LOG_DEBUG("http_request_done: %s", _res_buf);
                if (_t_conn) {
                    _t_conn->process_form_http(_res_buf, r_len);
                }

            }

            break;
        default:
            break;
   }
}

