1、每一个线程聚合一个epoll_helper
2、每一个线程start 之前将自己监听消息的句柄加入到自己线程的epoll_helper中
3、监听消息句柄 当epoll 有可读事件时， 调用epoll_wait 对应的事件处理函数。
监听消息的句柄事件处理函数是先读取数据， 读取数据， 如果数据是文件描述符， 说明是listen 线程发过来的
将此描述符加入到当前线程的epoll_helper中 --- 这是线程内部处理
如果是用户发过来的数据则接收 ， 调用用户设定的线程处理函数处理。--- 这是业务处理
监听句柄的事件处理函数 -- 读取数据并将新描述符加入到epoll_helper中
新描述符的事件处理函数 -- 读取数据并调用线程处理函数
线程间消息的格式

所有的消息都是tlv 格式
一个head 一个body, 不然不知道消息是否收全

内部消息和外部消息head 不一样。
不论是内部消息还是外部消息 需要发送或者接收均包装成内部消息头

每一个container 内部会注册 内部消息的fd的集合

container 为模板类， 模板参数为用户处理函数。



消息--- 内部消息--
				---接收--- 按最大消息长度接收， 取内部消息头长度， 看当前获取的长度是否够获取的长度是否大于body的长度，
										大于则放入就绪队列， 否则放入未就绪队列。
				---发送--  按要发送的消息长度发送


		--- 外部消息
				---接收
				---发送

有没有可能对同一个描述符先后发送两次消息?
第一条还没发， 另一条已经发过来了， 有可能， 内部消息， 多个线程都写日志，
都转发给日志线程处理--是可能的
而日志接收线程 只有1个fd, 若以fd 为key, 显然不合理。
so, 显然不能用map, 以fd为key
MSG_DONTWAIT 一次能接收完全吗？
如果一次接收不完全， 是继续循环接收， 还是等待下一次
怎么确认是否是同一条消息，


异步--有消息就读--读完了就干活，而不是等一个连接读， 没有读完就等待， 直到一个读完处理了
再处理下一个连接。
信道收到消息，1、new 一个新连接， 2、将收到的消息 调用其他连接的消息处理函数， 3、将收到的消息放到自己的待发送队列
普通连接收到消息调用消息处理函数， 发出消息放到自己待发送消息队列里， 
epoll  只负责监听事件是否到来,

listen 工作线程收到消息， 接收消息，并将新连接 发送给相应的工作线程

怎么发给工作线程呢？

知道工作线程id, 发给本线程所拥有的句柄， 消息传递线程收到消息后会将消息转发给目的线程
目的线程
工作线程


内部消息 主要做什么用
内部消息与外部消息之间的作用

内部消息

gen connect

先做水平模式
后做边缘模式

每一个socket 连接维持一个对象， 将该对象的指针加入到epoll 事件用户空间指针中。
当epoll 有事件到来时， 直接调用该epoll 对应的用户指针。
每一个连接分配一个id, 由每一个线程维护一个obj_id 生成就行， 不需要全局加锁

信息转发线程 收到消息-- 根据具体的内容--放到工作线程队列去， 再通知工作线程去取






----------改进---------
由listen 线程放置到工作线程

